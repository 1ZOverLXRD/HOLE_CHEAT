#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_GameInstance

#include "Basic.hpp"

#include "BPI_GameInstance_classes.hpp"
#include "BPI_GameInstance_parameters.hpp"


namespace SDK
{

// Function BPI_GameInstance.BPI_GameInstance_C.ApplyConfigData
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::ApplyConfigData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyConfigData");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ApplyConfigData_Audio
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Master                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   BGM                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   SE                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   UI                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::ApplyConfigData_Audio(uint8 Master, uint8 BGM, uint8 SE, uint8 UI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyConfigData_Audio");

	Params::BPI_GameInstance_C_ApplyConfigData_Audio Parms{};

	Parms.Master = Master;
	Parms.BGM = BGM;
	Parms.SE = SE;
	Parms.UI = UI;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ApplyConfigData_Control
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Sensitivity                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sensitivity_ADS                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sensitivity_ADS_Scope2x                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sensitivity_ADS_Scope4x                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InvertVerticalLook                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ToggleSprint                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ToggleWalk                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ToggleAim                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ToggleCrouch                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ToggleLean                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EnableWeaponScroll                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InvertWeaponScroll                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MouseSmoothing                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DisableControlAxisRotationInLean                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  GP_MovementDeadzone                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  GP_LookDeadzone                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  GP_ResponseCurve                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::ApplyConfigData_Control(int32 Sensitivity, int32 Sensitivity_ADS, int32 Sensitivity_ADS_Scope2x, int32 Sensitivity_ADS_Scope4x, bool InvertVerticalLook, bool ToggleSprint, bool ToggleWalk, bool ToggleAim, bool ToggleCrouch, bool ToggleLean, bool EnableWeaponScroll, bool InvertWeaponScroll, bool MouseSmoothing, bool DisableControlAxisRotationInLean, double GP_MovementDeadzone, double GP_LookDeadzone, double GP_ResponseCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyConfigData_Control");

	Params::BPI_GameInstance_C_ApplyConfigData_Control Parms{};

	Parms.Sensitivity = Sensitivity;
	Parms.Sensitivity_ADS = Sensitivity_ADS;
	Parms.Sensitivity_ADS_Scope2x = Sensitivity_ADS_Scope2x;
	Parms.Sensitivity_ADS_Scope4x = Sensitivity_ADS_Scope4x;
	Parms.InvertVerticalLook = InvertVerticalLook;
	Parms.ToggleSprint = ToggleSprint;
	Parms.ToggleWalk = ToggleWalk;
	Parms.ToggleAim = ToggleAim;
	Parms.ToggleCrouch = ToggleCrouch;
	Parms.ToggleLean = ToggleLean;
	Parms.EnableWeaponScroll = EnableWeaponScroll;
	Parms.InvertWeaponScroll = InvertWeaponScroll;
	Parms.MouseSmoothing = MouseSmoothing;
	Parms.DisableControlAxisRotationInLean = DisableControlAxisRotationInLean;
	Parms.GP_MovementDeadzone = GP_MovementDeadzone;
	Parms.GP_LookDeadzone = GP_LookDeadzone;
	Parms.GP_ResponseCurve = GP_ResponseCurve;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ApplyConfigData_Game
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EN_Language                             Language                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SendPlayData                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::ApplyConfigData_Game(EN_Language Language, bool SendPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyConfigData_Game");

	Params::BPI_GameInstance_C_ApplyConfigData_Game Parms{};

	Parms.Language = Language;
	Parms.SendPlayData = SendPlayData;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ApplyConfigData_Graphics
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EN_WindowMode                           WindowMode                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_DisplayResolution                    DisplayResolution                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Brightness                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   FOV                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_FPSLimit                             FPSLimit                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetroEffect                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  CameraShake                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    VSync                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DGI                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::ApplyConfigData_Graphics(EN_WindowMode WindowMode, EN_DisplayResolution DisplayResolution, double Brightness, int32 FOV, EN_FPSLimit FPSLimit, bool RetroEffect, double CameraShake, bool VSync, bool DGI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyConfigData_Graphics");

	Params::BPI_GameInstance_C_ApplyConfigData_Graphics Parms{};

	Parms.WindowMode = WindowMode;
	Parms.DisplayResolution = DisplayResolution;
	Parms.Brightness = Brightness;
	Parms.FOV = FOV;
	Parms.FPSLimit = FPSLimit;
	Parms.RetroEffect = RetroEffect;
	Parms.CameraShake = CameraShake;
	Parms.VSync = VSync;
	Parms.DGI = DGI;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ApplyConfigData_UI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Crosshair                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   TaskIcon                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   HUDMode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::ApplyConfigData_UI(bool Crosshair, uint8 TaskIcon, uint8 HUDMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyConfigData_UI");

	Params::BPI_GameInstance_C_ApplyConfigData_UI Parms{};

	Parms.Crosshair = Crosshair;
	Parms.TaskIcon = TaskIcon;
	Parms.HUDMode = HUDMode;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ApplyKeymapData_Gamepad
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class FName, struct FStr_ActionKeymap>&ActionKeyMap_Gamepad                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// const TMap<class FName, struct FStr_AxisKeymap>&AxisKeyMap_Gamepad                                     (BlueprintVisible, BlueprintReadOnly, Parm)

void IBPI_GameInstance_C::ApplyKeymapData_Gamepad(const TMap<class FName, struct FStr_ActionKeymap>& ActionKeyMap_Gamepad, const TMap<class FName, struct FStr_AxisKeymap>& AxisKeyMap_Gamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyKeymapData_Gamepad");

	Params::BPI_GameInstance_C_ApplyKeymapData_Gamepad Parms{};

	Parms.ActionKeyMap_Gamepad = std::move(ActionKeyMap_Gamepad);
	Parms.AxisKeyMap_Gamepad = std::move(AxisKeyMap_Gamepad);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ApplyKeymapData_KBM
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class FName, struct FStr_ActionKeymap>&ActionKeyMap                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// const TMap<class FName, struct FStr_AxisKeymap>&AxisKeyMap                                             (BlueprintVisible, BlueprintReadOnly, Parm)

void IBPI_GameInstance_C::ApplyKeymapData_KBM(const TMap<class FName, struct FStr_ActionKeymap>& ActionKeyMap, const TMap<class FName, struct FStr_AxisKeymap>& AxisKeyMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ApplyKeymapData_KBM");

	Params::BPI_GameInstance_C_ApplyKeymapData_KBM Parms{};

	Parms.ActionKeyMap = std::move(ActionKeyMap);
	Parms.AxisKeyMap = std::move(AxisKeyMap);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.CheckGameSaveDataIsLoaded
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsLoaded                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::CheckGameSaveDataIsLoaded(bool* IsLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "CheckGameSaveDataIsLoaded");

	Params::BPI_GameInstance_C_CheckGameSaveDataIsLoaded Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsLoaded != nullptr)
		*IsLoaded = Parms.IsLoaded;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetAAOLForFunctionLibrary
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   AimAngleOutLog                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetAAOLForFunctionLibrary(bool* AimAngleOutLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetAAOLForFunctionLibrary");

	Params::BPI_GameInstance_C_GetAAOLForFunctionLibrary Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (AimAngleOutLog != nullptr)
		*AimAngleOutLog = Parms.AimAngleOutLog;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetActionKeyDisplayName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStr_ActionKeymap&         Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class FName*                            Name_0                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetActionKeyDisplayName(const struct FStr_ActionKeymap& Key, class FName* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetActionKeyDisplayName");

	Params::BPI_GameInstance_C_GetActionKeyDisplayName Parms{};

	Parms.Key = std::move(Key);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Name_0 != nullptr)
		*Name_0 = Parms.Name_0;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetAllEventProgress
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, int32>*               EventProgress                                          (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetAllEventProgress(TMap<class FName, int32>* EventProgress, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetAllEventProgress");

	Params::BPI_GameInstance_C_GetAllEventProgress Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (EventProgress != nullptr)
		*EventProgress = std::move(Parms.EventProgress);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetAllOnceItemDropRateFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, double>*              AllOnceItemData                                        (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetAllOnceItemDropRateFromDB(TMap<class FName, double>* AllOnceItemData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetAllOnceItemDropRateFromDB");

	Params::BPI_GameInstance_C_GetAllOnceItemDropRateFromDB Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (AllOnceItemData != nullptr)
		*AllOnceItemData = std::move(Parms.AllOnceItemData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetAllSkillNameFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>*                    SkillRowName                                           (Parm, OutParm)

void IBPI_GameInstance_C::GetAllSkillNameFromDB(TArray<class FName>* SkillRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetAllSkillNameFromDB");

	Params::BPI_GameInstance_C_GetAllSkillNameFromDB Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (SkillRowName != nullptr)
		*SkillRowName = std::move(Parms.SkillRowName);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetAllWeaponNameAndCategoryFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class FName, struct FStr_WeaponNameAndSubCategory>*AllData                                                (Parm, OutParm)

void IBPI_GameInstance_C::GetAllWeaponNameAndCategoryFromDB(bool* Success, TMap<class FName, struct FStr_WeaponNameAndSubCategory>* AllData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetAllWeaponNameAndCategoryFromDB");

	Params::BPI_GameInstance_C_GetAllWeaponNameAndCategoryFromDB Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (AllData != nullptr)
		*AllData = std::move(Parms.AllData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetAmmoSpecDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AmmoRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_AmmoData*                   AmmoData                                               (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetAmmoSpecDataFromDB(class FName AmmoRowName, struct FStr_AmmoData* AmmoData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetAmmoSpecDataFromDB");

	Params::BPI_GameInstance_C_GetAmmoSpecDataFromDB Parms{};

	Parms.AmmoRowName = AmmoRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (AmmoData != nullptr)
		*AmmoData = std::move(Parms.AmmoData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetArmorPointData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ArmorPoint                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetArmorPointData(EPhysicalSurface SurfaceType, int32* ArmorPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetArmorPointData");

	Params::BPI_GameInstance_C_GetArmorPointData Parms{};

	Parms.SurfaceType = SurfaceType;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (ArmorPoint != nullptr)
		*ArmorPoint = Parms.ArmorPoint;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetCashItemDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             CashItemRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_CashItemData*               CashItemData                                           (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetCashItemDataFromDB(class FName CashItemRowName, bool* Success, struct FStr_CashItemData* CashItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetCashItemDataFromDB");

	Params::BPI_GameInstance_C_GetCashItemDataFromDB Parms{};

	Parms.CashItemRowName = CashItemRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (CashItemData != nullptr)
		*CashItemData = std::move(Parms.CashItemData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetColorTeamMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsColorTeamMode                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetColorTeamMode(bool* IsColorTeamMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetColorTeamMode");

	Params::BPI_GameInstance_C_GetColorTeamMode Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsColorTeamMode != nullptr)
		*IsColorTeamMode = Parms.IsColorTeamMode;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetConfigData_All
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USGO_ConfigData_C**               ConfigData                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetConfigData_All(class USGO_ConfigData_C** ConfigData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetConfigData_All");

	Params::BPI_GameInstance_C_GetConfigData_All Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (ConfigData != nullptr)
		*ConfigData = Parms.ConfigData;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetConfigData_Game
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8*                                  Language                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   SendPlayData                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetConfigData_Game(uint8* Language, bool* SendPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetConfigData_Game");

	Params::BPI_GameInstance_C_GetConfigData_Game Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Language != nullptr)
		*Language = Parms.Language;

	if (SendPlayData != nullptr)
		*SendPlayData = Parms.SendPlayData;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetConfigData_UI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   EnableCrosshair                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8*                                  TaskIcon                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8*                                  HUDMode                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetConfigData_UI(bool* EnableCrosshair, uint8* TaskIcon, uint8* HUDMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetConfigData_UI");

	Params::BPI_GameInstance_C_GetConfigData_UI Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (EnableCrosshair != nullptr)
		*EnableCrosshair = Parms.EnableCrosshair;

	if (TaskIcon != nullptr)
		*TaskIcon = Parms.TaskIcon;

	if (HUDMode != nullptr)
		*HUDMode = Parms.HUDMode;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetDataItemDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             DataItemRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_DataItemData*               DataItemData                                           (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetDataItemDataFromDB(class FName DataItemRowName, bool* Success, struct FStr_DataItemData* DataItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetDataItemDataFromDB");

	Params::BPI_GameInstance_C_GetDataItemDataFromDB Parms{};

	Parms.DataItemRowName = DataItemRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (DataItemData != nullptr)
		*DataItemData = std::move(Parms.DataItemData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetDebugFocusRender
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsDebug                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetDebugFocusRender(bool* IsDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetDebugFocusRender");

	Params::BPI_GameInstance_C_GetDebugFocusRender Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsDebug != nullptr)
		*IsDebug = Parms.IsDebug;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetDefaultConfigData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, bool>*                DefaultBool                                            (Parm, OutParm)
// TMap<class FName, uint8>*               DefaultByte                                            (Parm, OutParm)
// TMap<class FName, int32>*               DefaultInteger                                         (Parm, OutParm)
// TMap<class FName, double>*              DefaultFloat                                           (Parm, OutParm)

void IBPI_GameInstance_C::GetDefaultConfigData(TMap<class FName, bool>* DefaultBool, TMap<class FName, uint8>* DefaultByte, TMap<class FName, int32>* DefaultInteger, TMap<class FName, double>* DefaultFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetDefaultConfigData");

	Params::BPI_GameInstance_C_GetDefaultConfigData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (DefaultBool != nullptr)
		*DefaultBool = std::move(Parms.DefaultBool);

	if (DefaultByte != nullptr)
		*DefaultByte = std::move(Parms.DefaultByte);

	if (DefaultInteger != nullptr)
		*DefaultInteger = std::move(Parms.DefaultInteger);

	if (DefaultFloat != nullptr)
		*DefaultFloat = std::move(Parms.DefaultFloat);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetDefaultKeymapData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, struct FStr_AxisKeymap>*DefaultAxis_KBM                                        (Parm, OutParm)
// TMap<class FName, struct FStr_ActionKeymap>*DefaultAction_KBM                                      (Parm, OutParm)
// TMap<class FName, struct FStr_AxisKeymap>*DefaultAxis_GP                                         (Parm, OutParm)
// TMap<class FName, struct FStr_ActionKeymap>*DefaultAction_GP                                       (Parm, OutParm)

void IBPI_GameInstance_C::GetDefaultKeymapData(TMap<class FName, struct FStr_AxisKeymap>* DefaultAxis_KBM, TMap<class FName, struct FStr_ActionKeymap>* DefaultAction_KBM, TMap<class FName, struct FStr_AxisKeymap>* DefaultAxis_GP, TMap<class FName, struct FStr_ActionKeymap>* DefaultAction_GP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetDefaultKeymapData");

	Params::BPI_GameInstance_C_GetDefaultKeymapData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (DefaultAxis_KBM != nullptr)
		*DefaultAxis_KBM = std::move(Parms.DefaultAxis_KBM);

	if (DefaultAction_KBM != nullptr)
		*DefaultAction_KBM = std::move(Parms.DefaultAction_KBM);

	if (DefaultAxis_GP != nullptr)
		*DefaultAxis_GP = std::move(Parms.DefaultAxis_GP);

	if (DefaultAction_GP != nullptr)
		*DefaultAction_GP = std::move(Parms.DefaultAction_GP);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetDiscDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             DiscRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_DiscType*                   DiscData                                               (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetDiscDataFromDB(class FName DiscRowName, bool* Success, struct FStr_DiscType* DiscData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetDiscDataFromDB");

	Params::BPI_GameInstance_C_GetDiscDataFromDB Parms{};

	Parms.DiscRowName = DiscRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (DiscData != nullptr)
		*DiscData = std::move(Parms.DiscData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetDLSForFunctionLibrary
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStr_DebugLogSetting*            DebugLogSetting                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetDLSForFunctionLibrary(struct FStr_DebugLogSetting* DebugLogSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetDLSForFunctionLibrary");

	Params::BPI_GameInstance_C_GetDLSForFunctionLibrary Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (DebugLogSetting != nullptr)
		*DebugLogSetting = std::move(Parms.DebugLogSetting);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetEventProgress
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Progress                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetEventProgress(class FName EventName, int32* Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetEventProgress");

	Params::BPI_GameInstance_C_GetEventProgress Parms{};

	Parms.EventName = EventName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Progress != nullptr)
		*Progress = Parms.Progress;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetFactionalRelationShip
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EN_Faction                              SelfFaction                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_Faction                              OtherFaction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsFrendry                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetFactionalRelationShip(EN_Faction SelfFaction, EN_Faction OtherFaction, bool* IsFrendry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetFactionalRelationShip");

	Params::BPI_GameInstance_C_GetFactionalRelationShip Parms{};

	Parms.SelfFaction = SelfFaction;
	Parms.OtherFaction = OtherFaction;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsFrendry != nullptr)
		*IsFrendry = Parms.IsFrendry;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetFridgeDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             FridgeRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_FridgeData*                 FridgeData                                             (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetFridgeDataFromDB(class FName FridgeRowName, struct FStr_FridgeData* FridgeData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetFridgeDataFromDB");

	Params::BPI_GameInstance_C_GetFridgeDataFromDB Parms{};

	Parms.FridgeRowName = FridgeRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (FridgeData != nullptr)
		*FridgeData = std::move(Parms.FridgeData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetFTSForFunctionLibrary
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   FireTrace                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   BulletSpeed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetFTSForFunctionLibrary(bool* FireTrace, bool* BulletSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetFTSForFunctionLibrary");

	Params::BPI_GameInstance_C_GetFTSForFunctionLibrary Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (FireTrace != nullptr)
		*FireTrace = Parms.FireTrace;

	if (BulletSpeed != nullptr)
		*BulletSpeed = Parms.BulletSpeed;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetGunBaseSpecFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_GunSpecData*                GunBaseSpec                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetGunBaseSpecFromDB(class FName WeaponRowName, struct FStr_GunSpecData* GunBaseSpec, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetGunBaseSpecFromDB");

	Params::BPI_GameInstance_C_GetGunBaseSpecFromDB Parms{};

	Parms.WeaponRowName = WeaponRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (GunBaseSpec != nullptr)
		*GunBaseSpec = std::move(Parms.GunBaseSpec);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetGunPartsDataByCategoryFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_GunPartsCategory                     PartsCategory                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FName>*                    GunPartsRowNames                                       (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetGunPartsDataByCategoryFromDB(class FName WeaponRowName, EN_GunPartsCategory PartsCategory, TArray<class FName>* GunPartsRowNames, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetGunPartsDataByCategoryFromDB");

	Params::BPI_GameInstance_C_GetGunPartsDataByCategoryFromDB Parms{};

	Parms.WeaponRowName = WeaponRowName;
	Parms.PartsCategory = PartsCategory;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (GunPartsRowNames != nullptr)
		*GunPartsRowNames = std::move(Parms.GunPartsRowNames);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetGunPartsDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             GunPartsRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_GunPartsData*               GunPartsData                                           (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetGunPartsDataFromDB(class FName GunPartsRowName, struct FStr_GunPartsData* GunPartsData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetGunPartsDataFromDB");

	Params::BPI_GameInstance_C_GetGunPartsDataFromDB Parms{};

	Parms.GunPartsRowName = GunPartsRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (GunPartsData != nullptr)
		*GunPartsData = std::move(Parms.GunPartsData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetHitDamageMultiplierData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPhysicalSurface                        HitSurfaceType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsArmorPenetrated                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 DamageMultiplier                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetHitDamageMultiplierData(EPhysicalSurface HitSurfaceType, bool IsArmorPenetrated, double* DamageMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetHitDamageMultiplierData");

	Params::BPI_GameInstance_C_GetHitDamageMultiplierData Parms{};

	Parms.HitSurfaceType = HitSurfaceType;
	Parms.IsArmorPenetrated = IsArmorPenetrated;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (DamageMultiplier != nullptr)
		*DamageMultiplier = Parms.DamageMultiplier;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetHitStunDamageMultiplierData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPhysicalSurface                        HitSurface                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Multiplier                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetHitStunDamageMultiplierData(EPhysicalSurface HitSurface, double* Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetHitStunDamageMultiplierData");

	Params::BPI_GameInstance_C_GetHitStunDamageMultiplierData Parms{};

	Parms.HitSurface = HitSurface;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Multiplier != nullptr)
		*Multiplier = Parms.Multiplier;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetHomeFacilityDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             FacilityRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_HomeFacilityData*           FacilityData                                           (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetHomeFacilityDataFromDB(class FName FacilityRowName, struct FStr_HomeFacilityData* FacilityData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetHomeFacilityDataFromDB");

	Params::BPI_GameInstance_C_GetHomeFacilityDataFromDB Parms{};

	Parms.FacilityRowName = FacilityRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (FacilityData != nullptr)
		*FacilityData = std::move(Parms.FacilityData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetInputKeyByActionName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ActionName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_ActionKeymap*               Key                                                    (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetInputKeyByActionName(class FName ActionName, struct FStr_ActionKeymap* Key, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetInputKeyByActionName");

	Params::BPI_GameInstance_C_GetInputKeyByActionName Parms{};

	Parms.ActionName = ActionName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetInputKeyIconMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsGamepadMode                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetInputKeyIconMode(bool* IsGamepadMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetInputKeyIconMode");

	Params::BPI_GameInstance_C_GetInputKeyIconMode Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsGamepadMode != nullptr)
		*IsGamepadMode = Parms.IsGamepadMode;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetIsReturnToTitle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsReturnToTitle                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetIsReturnToTitle(bool* IsReturnToTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetIsReturnToTitle");

	Params::BPI_GameInstance_C_GetIsReturnToTitle Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsReturnToTitle != nullptr)
		*IsReturnToTitle = Parms.IsReturnToTitle;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetKeyIconFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UTexture**                        Icon                                                   (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetKeyIconFromDB(const struct FKey& Key, class UTexture** Icon, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetKeyIconFromDB");

	Params::BPI_GameInstance_C_GetKeyIconFromDB Parms{};

	Parms.Key = std::move(Key);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Icon != nullptr)
		*Icon = Parms.Icon;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetKeymapData_All
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USGO_KeymapData_C**               KeymapData                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetKeymapData_All(class USGO_KeymapData_C** KeymapData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetKeymapData_All");

	Params::BPI_GameInstance_C_GetKeymapData_All Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (KeymapData != nullptr)
		*KeymapData = Parms.KeymapData;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetLevelDataImageFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AreaRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture2D**                      Image                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetLevelDataImageFromDB(class FName AreaRowName, class UTexture2D** Image, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetLevelDataImageFromDB");

	Params::BPI_GameInstance_C_GetLevelDataImageFromDB Parms{};

	Parms.AreaRowName = AreaRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Image != nullptr)
		*Image = Parms.Image;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetLevelNameFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AreaRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText*                            Name_0                                                 (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetLevelNameFromDB(class FName AreaRowName, class FText* Name_0, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetLevelNameFromDB");

	Params::BPI_GameInstance_C_GetLevelNameFromDB Parms{};

	Parms.AreaRowName = AreaRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetLockedWeaponPartsOnlyUnlockedWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>*                    WeaponPartsRowNames                                    (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetLockedWeaponPartsOnlyUnlockedWeapon(TArray<class FName>* WeaponPartsRowNames, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetLockedWeaponPartsOnlyUnlockedWeapon");

	Params::BPI_GameInstance_C_GetLockedWeaponPartsOnlyUnlockedWeapon Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (WeaponPartsRowNames != nullptr)
		*WeaponPartsRowNames = std::move(Parms.WeaponPartsRowNames);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetMeleeBaseSpecFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_MeleeBaseSpecData*          BaseSpec                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetMeleeBaseSpecFromDB(class FName WeaponRowName, struct FStr_MeleeBaseSpecData* BaseSpec, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetMeleeBaseSpecFromDB");

	Params::BPI_GameInstance_C_GetMeleeBaseSpecFromDB Parms{};

	Parms.WeaponRowName = WeaponRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (BaseSpec != nullptr)
		*BaseSpec = std::move(Parms.BaseSpec);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetMeleePartsDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             MeleePartsRowName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_MeleePartsData*             MeleePartsData                                         (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetMeleePartsDataFromDB(class FName MeleePartsRowName, struct FStr_MeleePartsData* MeleePartsData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetMeleePartsDataFromDB");

	Params::BPI_GameInstance_C_GetMeleePartsDataFromDB Parms{};

	Parms.MeleePartsRowName = MeleePartsRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (MeleePartsData != nullptr)
		*MeleePartsData = std::move(Parms.MeleePartsData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetNewTaskFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName*                            NewTaskRowName                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsRepeatTask                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetNewTaskFromDB(class FName* NewTaskRowName, bool* IsRepeatTask, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetNewTaskFromDB");

	Params::BPI_GameInstance_C_GetNewTaskFromDB Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (NewTaskRowName != nullptr)
		*NewTaskRowName = Parms.NewTaskRowName;

	if (IsRepeatTask != nullptr)
		*IsRepeatTask = Parms.IsRepeatTask;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetNPCAutoMantle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsAutoMantle                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetNPCAutoMantle(bool* IsAutoMantle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetNPCAutoMantle");

	Params::BPI_GameInstance_C_GetNPCAutoMantle Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsAutoMantle != nullptr)
		*IsAutoMantle = Parms.IsAutoMantle;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetNPCDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NPCRowName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_NPCData*                    NPC_Data                                               (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetNPCDataFromDB(class FName NPCRowName, bool* Success, struct FStr_NPCData* NPC_Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetNPCDataFromDB");

	Params::BPI_GameInstance_C_GetNPCDataFromDB Parms{};

	Parms.NPCRowName = NPCRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (NPC_Data != nullptr)
		*NPC_Data = std::move(Parms.NPC_Data);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetNPCTaskViewMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsEnable                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetNPCTaskViewMode(bool* IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetNPCTaskViewMode");

	Params::BPI_GameInstance_C_GetNPCTaskViewMode Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsEnable != nullptr)
		*IsEnable = Parms.IsEnable;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetObjectDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ObjectRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_ObjectData*                 ObjectData                                             (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetObjectDataFromDB(class FName ObjectRowName, struct FStr_ObjectData* ObjectData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetObjectDataFromDB");

	Params::BPI_GameInstance_C_GetObjectDataFromDB Parms{};

	Parms.ObjectRowName = ObjectRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (ObjectData != nullptr)
		*ObjectData = std::move(Parms.ObjectData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetOnceItemDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             OnceItemRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_OnceItemData*               OnceItemData                                           (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetOnceItemDataFromDB(class FName OnceItemRowName, bool* Success, struct FStr_OnceItemData* OnceItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetOnceItemDataFromDB");

	Params::BPI_GameInstance_C_GetOnceItemDataFromDB Parms{};

	Parms.OnceItemRowName = OnceItemRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (OnceItemData != nullptr)
		*OnceItemData = std::move(Parms.OnceItemData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetPrototypeConfigData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   CameraShake                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetPrototypeConfigData(bool* CameraShake)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetPrototypeConfigData");

	Params::BPI_GameInstance_C_GetPrototypeConfigData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CameraShake != nullptr)
		*CameraShake = Parms.CameraShake;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetRaytraceGropIDsFromGameInstance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  ID                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetRaytraceGropIDsFromGameInstance(int32* ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetRaytraceGropIDsFromGameInstance");

	Params::BPI_GameInstance_C_GetRaytraceGropIDsFromGameInstance Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (ID != nullptr)
		*ID = Parms.ID;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetReward
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStr_TaskReward&           Reward                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetReward(const struct FStr_TaskReward& Reward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetReward");

	Params::BPI_GameInstance_C_GetReward Parms{};

	Parms.Reward = std::move(Reward);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_AreaUnlockData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSet<class FName>*                      AreaUnlocked                                           (Parm, OutParm)

void IBPI_GameInstance_C::GetSaveData_AreaUnlockData(TSet<class FName>* AreaUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_AreaUnlockData");

	Params::BPI_GameInstance_C_GetSaveData_AreaUnlockData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (AreaUnlocked != nullptr)
		*AreaUnlocked = std::move(Parms.AreaUnlocked);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_ClearTaskCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TaskID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_ClearTaskCount(class FName TaskID, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_ClearTaskCount");

	Params::BPI_GameInstance_C_GetSaveData_ClearTaskCount Parms{};

	Parms.TaskID = TaskID;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_CurrentAmmo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<EWeaponSelector, struct FStr_CurrentAmmo>*CurrentAmmo                                            (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_CurrentAmmo(TMap<EWeaponSelector, struct FStr_CurrentAmmo>* CurrentAmmo, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_CurrentAmmo");

	Params::BPI_GameInstance_C_GetSaveData_CurrentAmmo Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CurrentAmmo != nullptr)
		*CurrentAmmo = std::move(Parms.CurrentAmmo);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_CurrentTask
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<uint8, struct FStr_TaskCardState>* Task                                                   (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_CurrentTask(TMap<uint8, struct FStr_TaskCardState>* Task, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_CurrentTask");

	Params::BPI_GameInstance_C_GetSaveData_CurrentTask Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Task != nullptr)
		*Task = std::move(Parms.Task);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_CurrentTaskItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TaskItemRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_CurrentTaskItems(class FName TaskItemRowName, int32* Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_CurrentTaskItems");

	Params::BPI_GameInstance_C_GetSaveData_CurrentTaskItems Parms{};

	Parms.TaskItemRowName = TaskItemRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Amount != nullptr)
		*Amount = Parms.Amount;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_CurrentWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EWeaponSelector*                        CurrentWeaponSelector                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_CurrentWeapon(EWeaponSelector* CurrentWeaponSelector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_CurrentWeapon");

	Params::BPI_GameInstance_C_GetSaveData_CurrentWeapon Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CurrentWeaponSelector != nullptr)
		*CurrentWeaponSelector = Parms.CurrentWeaponSelector;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_EquipWeaponData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<EWeaponSelector, class FName>*     WeaponData                                             (Parm, OutParm)

void IBPI_GameInstance_C::GetSaveData_EquipWeaponData(TMap<EWeaponSelector, class FName>* WeaponData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_EquipWeaponData");

	Params::BPI_GameInstance_C_GetSaveData_EquipWeaponData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (WeaponData != nullptr)
		*WeaponData = std::move(Parms.WeaponData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_IsClearedAllTask
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsAllClear                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_IsClearedAllTask(bool* IsAllClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_IsClearedAllTask");

	Params::BPI_GameInstance_C_GetSaveData_IsClearedAllTask Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsAllClear != nullptr)
		*IsAllClear = Parms.IsAllClear;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_IsUnlockedShopItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SkillRowName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsUnlocked                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_IsUnlockedShopItem(class FName SkillRowName, bool* IsUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_IsUnlockedShopItem");

	Params::BPI_GameInstance_C_GetSaveData_IsUnlockedShopItem Parms{};

	Parms.SkillRowName = SkillRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsUnlocked != nullptr)
		*IsUnlocked = Parms.IsUnlocked;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_IsUnlockedWeaponPartsBlueprint
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponPartsRowName                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsUnlocked                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_IsUnlockedWeaponPartsBlueprint(class FName WeaponPartsRowName, bool* IsUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_IsUnlockedWeaponPartsBlueprint");

	Params::BPI_GameInstance_C_GetSaveData_IsUnlockedWeaponPartsBlueprint Parms{};

	Parms.WeaponPartsRowName = WeaponPartsRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsUnlocked != nullptr)
		*IsUnlocked = Parms.IsUnlocked;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_PlayerStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  Cash                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class FName, int32>*               Disc                                                   (Parm, OutParm)

void IBPI_GameInstance_C::GetSaveData_PlayerStats(int32* Cash, int32* Data, TMap<class FName, int32>* Disc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_PlayerStats");

	Params::BPI_GameInstance_C_GetSaveData_PlayerStats Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Cash != nullptr)
		*Cash = Parms.Cash;

	if (Data != nullptr)
		*Data = Parms.Data;

	if (Disc != nullptr)
		*Disc = std::move(Parms.Disc);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_PurchasedWeaponParts
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSet<class FName>*                      WeaponPartsRowName                                     (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_PurchasedWeaponParts(TSet<class FName>* WeaponPartsRowName, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_PurchasedWeaponParts");

	Params::BPI_GameInstance_C_GetSaveData_PurchasedWeaponParts Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (WeaponPartsRowName != nullptr)
		*WeaponPartsRowName = std::move(Parms.WeaponPartsRowName);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_RoomKeyUnlockData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             KeyName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsUnlocked                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_RoomKeyUnlockData(class FName KeyName, bool* IsUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_RoomKeyUnlockData");

	Params::BPI_GameInstance_C_GetSaveData_RoomKeyUnlockData Parms{};

	Parms.KeyName = KeyName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsUnlocked != nullptr)
		*IsUnlocked = Parms.IsUnlocked;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_SkillLevel_Activated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SkillRowName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  SkillLv                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_SkillLevel_Activated(class FName SkillRowName, bool* Success, int32* SkillLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_SkillLevel_Activated");

	Params::BPI_GameInstance_C_GetSaveData_SkillLevel_Activated Parms{};

	Parms.SkillRowName = SkillRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (SkillLv != nullptr)
		*SkillLv = Parms.SkillLv;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_SkillLevel_Unlocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SkillRowName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  SkillLv                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_SkillLevel_Unlocked(class FName SkillRowName, bool* Success, int32* SkillLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_SkillLevel_Unlocked");

	Params::BPI_GameInstance_C_GetSaveData_SkillLevel_Unlocked Parms{};

	Parms.SkillRowName = SkillRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (SkillLv != nullptr)
		*SkillLv = Parms.SkillLv;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_SkillLevel_UnlockedAll
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, int32>*               Skill                                                  (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_SkillLevel_UnlockedAll(TMap<class FName, int32>* Skill, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_SkillLevel_UnlockedAll");

	Params::BPI_GameInstance_C_GetSaveData_SkillLevel_UnlockedAll Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Skill != nullptr)
		*Skill = std::move(Parms.Skill);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_UnlockGunIDList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>*                    GunRowName                                             (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_UnlockGunIDList(TArray<class FName>* GunRowName, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_UnlockGunIDList");

	Params::BPI_GameInstance_C_GetSaveData_UnlockGunIDList Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (GunRowName != nullptr)
		*GunRowName = std::move(Parms.GunRowName);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_UnlockGunIDList_Length
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  Length                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_UnlockGunIDList_Length(int32* Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_UnlockGunIDList_Length");

	Params::BPI_GameInstance_C_GetSaveData_UnlockGunIDList_Length Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Length != nullptr)
		*Length = Parms.Length;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_UnlockWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsUnlock                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_UnlockWeapon(class FName WeaponRowName, bool* IsUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_UnlockWeapon");

	Params::BPI_GameInstance_C_GetSaveData_UnlockWeapon Parms{};

	Parms.WeaponRowName = WeaponRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsUnlock != nullptr)
		*IsUnlock = Parms.IsUnlock;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_WeaponCustomMetaData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_WeaponCustomMetaData*       WeaponCustomMetaData                                   (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_WeaponCustomMetaData(class FName WeaponRowName, bool* Success, struct FStr_WeaponCustomMetaData* WeaponCustomMetaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_WeaponCustomMetaData");

	Params::BPI_GameInstance_C_GetSaveData_WeaponCustomMetaData Parms{};

	Parms.WeaponRowName = WeaponRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (WeaponCustomMetaData != nullptr)
		*WeaponCustomMetaData = std::move(Parms.WeaponCustomMetaData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSaveData_WeaponCustomSaveData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_WeaponCustomSaveData_Temp*  WeaponCustomSaveData                                   (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSaveData_WeaponCustomSaveData(class FName WeaponRowName, bool* Success, struct FStr_WeaponCustomSaveData_Temp* WeaponCustomSaveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSaveData_WeaponCustomSaveData");

	Params::BPI_GameInstance_C_GetSaveData_WeaponCustomSaveData Parms{};

	Parms.WeaponRowName = WeaponRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (WeaponCustomSaveData != nullptr)
		*WeaponCustomSaveData = std::move(Parms.WeaponCustomSaveData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetSkillDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             RowName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_SkillData*                  SkillData                                              (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetSkillDataFromDB(class FName RowName, bool* Success, struct FStr_SkillData* SkillData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetSkillDataFromDB");

	Params::BPI_GameInstance_C_GetSkillDataFromDB Parms{};

	Parms.RowName = RowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (SkillData != nullptr)
		*SkillData = std::move(Parms.SkillData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetTaskDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TaskRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_TaskData*                   TaskData                                               (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetTaskDataFromDB(class FName TaskRowName, struct FStr_TaskData* TaskData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetTaskDataFromDB");

	Params::BPI_GameInstance_C_GetTaskDataFromDB Parms{};

	Parms.TaskRowName = TaskRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (TaskData != nullptr)
		*TaskData = std::move(Parms.TaskData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetTaskItemDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TaskItemRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_TaskItemData*               TaskItemData                                           (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetTaskItemDataFromDB(class FName TaskItemRowName, struct FStr_TaskItemData* TaskItemData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetTaskItemDataFromDB");

	Params::BPI_GameInstance_C_GetTaskItemDataFromDB Parms{};

	Parms.TaskItemRowName = TaskItemRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (TaskItemData != nullptr)
		*TaskItemData = std::move(Parms.TaskItemData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetUIColor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLinearColor*                    PrimaryColor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    SecondaryColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    TextActiveColor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    TextDeactiveColor                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    RejectColor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetUIColor(struct FLinearColor* PrimaryColor, struct FLinearColor* SecondaryColor, struct FLinearColor* TextActiveColor, struct FLinearColor* TextDeactiveColor, struct FLinearColor* RejectColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetUIColor");

	Params::BPI_GameInstance_C_GetUIColor Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (PrimaryColor != nullptr)
		*PrimaryColor = std::move(Parms.PrimaryColor);

	if (SecondaryColor != nullptr)
		*SecondaryColor = std::move(Parms.SecondaryColor);

	if (TextActiveColor != nullptr)
		*TextActiveColor = std::move(Parms.TextActiveColor);

	if (TextDeactiveColor != nullptr)
		*TextDeactiveColor = std::move(Parms.TextDeactiveColor);

	if (RejectColor != nullptr)
		*RejectColor = std::move(Parms.RejectColor);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetWeaponDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             RowName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_WeaponData*                 WeaponData                                             (Parm, OutParm, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetWeaponDataFromDB(class FName RowName, bool* Success, struct FStr_WeaponData* WeaponData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetWeaponDataFromDB");

	Params::BPI_GameInstance_C_GetWeaponDataFromDB Parms{};

	Parms.RowName = RowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (WeaponData != nullptr)
		*WeaponData = std::move(Parms.WeaponData);
}


// Function BPI_GameInstance.BPI_GameInstance_C.GetWeaponPartsDataFromDB
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponPartsRowName                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_WeaponPartsCategory*                 WeaponPartsCategory                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_GunPartsData*               GunPartsData                                           (Parm, OutParm, HasGetValueTypeHash)
// struct FStr_MeleePartsData*             MeleePartsData                                         (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::GetWeaponPartsDataFromDB(class FName WeaponPartsRowName, EN_WeaponPartsCategory* WeaponPartsCategory, struct FStr_GunPartsData* GunPartsData, struct FStr_MeleePartsData* MeleePartsData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "GetWeaponPartsDataFromDB");

	Params::BPI_GameInstance_C_GetWeaponPartsDataFromDB Parms{};

	Parms.WeaponPartsRowName = WeaponPartsRowName;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (WeaponPartsCategory != nullptr)
		*WeaponPartsCategory = Parms.WeaponPartsCategory;

	if (GunPartsData != nullptr)
		*GunPartsData = std::move(Parms.GunPartsData);

	if (MeleePartsData != nullptr)
		*MeleePartsData = std::move(Parms.MeleePartsData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.HandOverTaskItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class FName, int32>&         RequireItem                                            (BlueprintVisible, BlueprintReadOnly, Parm)

void IBPI_GameInstance_C::HandOverTaskItem(const TMap<class FName, int32>& RequireItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "HandOverTaskItem");

	Params::BPI_GameInstance_C_HandOverTaskItem Parms{};

	Parms.RequireItem = std::move(RequireItem);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.InitializeRaytraceGroupID
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::InitializeRaytraceGroupID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "InitializeRaytraceGroupID");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ResetSaveData
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::ResetSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ResetSaveData");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.ResetSaveData_PlayerStats
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::ResetSaveData_PlayerStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "ResetSaveData_PlayerStats");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SaveSaveData_All
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SaveSaveData_All(bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SaveSaveData_All");

	Params::BPI_GameInstance_C_SaveSaveData_All Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.SendPlayData_GameEnd
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::SendPlayData_GameEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SendPlayData_GameEnd");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SendPlayData_GameStart
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::SendPlayData_GameStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SendPlayData_GameStart");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SendPlayData_Initialize
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::SendPlayData_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SendPlayData_Initialize");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SendPlayData_Result
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStr_SendPlayData_Result&  ResultData                                             (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void IBPI_GameInstance_C::SendPlayData_Result(const struct FStr_SendPlayData_Result& ResultData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SendPlayData_Result");

	Params::BPI_GameInstance_C_SendPlayData_Result Parms{};

	Parms.ResultData = std::move(ResultData);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetColorTeamMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsColorTeamMode                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetColorTeamMode(bool IsColorTeamMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetColorTeamMode");

	Params::BPI_GameInstance_C_SetColorTeamMode Parms{};

	Parms.IsColorTeamMode = IsColorTeamMode;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetEventProgress
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Progress                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetEventProgress(class FName EventName, int32 Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetEventProgress");

	Params::BPI_GameInstance_C_SetEventProgress Parms{};

	Parms.EventName = EventName;
	Parms.Progress = Progress;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetInputKeyIconMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsGamapadMode                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetInputKeyIconMode(bool IsGamapadMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetInputKeyIconMode");

	Params::BPI_GameInstance_C_SetInputKeyIconMode Parms{};

	Parms.IsGamapadMode = IsGamapadMode;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetIsReturnToTitle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsReturnToTitle                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetIsReturnToTitle(bool IsReturnToTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetIsReturnToTitle");

	Params::BPI_GameInstance_C_SetIsReturnToTitle Parms{};

	Parms.IsReturnToTitle = IsReturnToTitle;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_AddAllPurchasedWeaponParts
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::SetSaveData_AddAllPurchasedWeaponParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_AddAllPurchasedWeaponParts");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_AddClearTaskCounts
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Task                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetSaveData_AddClearTaskCounts(class FName Task)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_AddClearTaskCounts");

	Params::BPI_GameInstance_C_SetSaveData_AddClearTaskCounts Parms{};

	Parms.Task = Task;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_AddPurchasedWeaponParts
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<class FName>&              WeaponPartsRowName                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void IBPI_GameInstance_C::SetSaveData_AddPurchasedWeaponParts(const TArray<class FName>& WeaponPartsRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_AddPurchasedWeaponParts");

	Params::BPI_GameInstance_C_SetSaveData_AddPurchasedWeaponParts Parms{};

	Parms.WeaponPartsRowName = std::move(WeaponPartsRowName);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_CurrentAmmo
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<EWeaponSelector, struct FStr_CurrentAmmo>&CurrentAmmo                                            (BlueprintVisible, BlueprintReadOnly, Parm)

void IBPI_GameInstance_C::SetSaveData_CurrentAmmo(const TMap<EWeaponSelector, struct FStr_CurrentAmmo>& CurrentAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_CurrentAmmo");

	Params::BPI_GameInstance_C_SetSaveData_CurrentAmmo Parms{};

	Parms.CurrentAmmo = std::move(CurrentAmmo);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_CurrentTask
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<uint8, struct FStr_TaskCardState>&CurrentTask                                            (BlueprintVisible, BlueprintReadOnly, Parm)

void IBPI_GameInstance_C::SetSaveData_CurrentTask(const TMap<uint8, struct FStr_TaskCardState>& CurrentTask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_CurrentTask");

	Params::BPI_GameInstance_C_SetSaveData_CurrentTask Parms{};

	Parms.CurrentTask = std::move(CurrentTask);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_CurrentTaskItems
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TaskItemRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetSaveData_CurrentTaskItems(class FName TaskItemRowName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_CurrentTaskItems");

	Params::BPI_GameInstance_C_SetSaveData_CurrentTaskItems Parms{};

	Parms.TaskItemRowName = TaskItemRowName;
	Parms.Amount = Amount;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_CurrentWeapon
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::SetSaveData_CurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_CurrentWeapon");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_EquipWeaponData
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::SetSaveData_EquipWeaponData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_EquipWeaponData");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_PlayerStats
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Cash                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TMap<class FName, int32>&         Disc                                                   (BlueprintVisible, BlueprintReadOnly, Parm)

void IBPI_GameInstance_C::SetSaveData_PlayerStats(int32 Cash, int32 Data, const TMap<class FName, int32>& Disc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_PlayerStats");

	Params::BPI_GameInstance_C_SetSaveData_PlayerStats Parms{};

	Parms.Cash = Cash;
	Parms.Data = Data;
	Parms.Disc = std::move(Disc);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_SkillLevel_Activated
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SkillRowName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SkillLv                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetSaveData_SkillLevel_Activated(class FName SkillRowName, int32 SkillLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_SkillLevel_Activated");

	Params::BPI_GameInstance_C_SetSaveData_SkillLevel_Activated Parms{};

	Parms.SkillRowName = SkillRowName;
	Parms.SkillLv = SkillLv;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_SkillLevel_Unlocked
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SkillRowName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SkillLv                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetSaveData_SkillLevel_Unlocked(class FName SkillRowName, int32 SkillLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_SkillLevel_Unlocked");

	Params::BPI_GameInstance_C_SetSaveData_SkillLevel_Unlocked Parms{};

	Parms.SkillRowName = SkillRowName;
	Parms.SkillLv = SkillLv;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_UnlockedAllWeaponPartsBlueprint
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_GameInstance_C::SetSaveData_UnlockedAllWeaponPartsBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_UnlockedAllWeaponPartsBlueprint");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_UnlockedWeaponPartsBlueprint
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PartsRowName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetSaveData_UnlockedWeaponPartsBlueprint(class FName PartsRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_UnlockedWeaponPartsBlueprint");

	Params::BPI_GameInstance_C_SetSaveData_UnlockedWeaponPartsBlueprint Parms{};

	Parms.PartsRowName = PartsRowName;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_UnlockWeapon
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUnlock                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetSaveData_UnlockWeapon(class FName WeaponRowName, bool IsUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_UnlockWeapon");

	Params::BPI_GameInstance_C_SetSaveData_UnlockWeapon Parms{};

	Parms.WeaponRowName = WeaponRowName;
	Parms.IsUnlock = IsUnlock;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetSaveData_WeaponCustomSaveData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WeaponRowName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FStr_WeaponCustomSaveData_Temp&WeaponCustomSaveData                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetSaveData_WeaponCustomSaveData(class FName WeaponRowName, const struct FStr_WeaponCustomSaveData_Temp& WeaponCustomSaveData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetSaveData_WeaponCustomSaveData");

	Params::BPI_GameInstance_C_SetSaveData_WeaponCustomSaveData Parms{};

	Parms.WeaponRowName = WeaponRowName;
	Parms.WeaponCustomSaveData = std::move(WeaponCustomSaveData);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.SetShopMachine
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Machine                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::SetShopMachine(class AActor* Machine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "SetShopMachine");

	Params::BPI_GameInstance_C_SetShopMachine Parms{};

	Parms.Machine = Machine;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.TempApply_Graphics_Brightness
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Brightness                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::TempApply_Graphics_Brightness(double Brightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "TempApply_Graphics_Brightness");

	Params::BPI_GameInstance_C_TempApply_Graphics_Brightness Parms{};

	Parms.Brightness = Brightness;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.TempApply_Graphics_FOV
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   FieldOfView                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::TempApply_Graphics_FOV(int32 FieldOfView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "TempApply_Graphics_FOV");

	Params::BPI_GameInstance_C_TempApply_Graphics_FOV Parms{};

	Parms.FieldOfView = FieldOfView;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.TempApply_Graphics_RetroEffect
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    RetroEffect                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::TempApply_Graphics_RetroEffect(bool RetroEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "TempApply_Graphics_RetroEffect");

	Params::BPI_GameInstance_C_TempApply_Graphics_RetroEffect Parms{};

	Parms.RetroEffect = RetroEffect;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_GameInstance.BPI_GameInstance_C.UseCash
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Cash                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::UseCash(int32 Cash, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "UseCash");

	Params::BPI_GameInstance_C_UseCash Parms{};

	Parms.Cash = Cash;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.UseData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::UseData(int32 Data, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "UseData");

	Params::BPI_GameInstance_C_UseData Parms{};

	Parms.Data = Data;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BPI_GameInstance.BPI_GameInstance_C.UseDisc
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStr_DiscType_Amount&      Disc                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_GameInstance_C::UseDisc(const struct FStr_DiscType_Amount& Disc, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_GameInstance_C", "UseDisc");

	Params::BPI_GameInstance_C_UseDisc Parms{};

	Parms.Disc = std::move(Disc);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}

}

