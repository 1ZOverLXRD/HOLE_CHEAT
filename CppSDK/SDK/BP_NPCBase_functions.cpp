#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_NPCBase

#include "Basic.hpp"

#include "BP_NPCBase_classes.hpp"
#include "BP_NPCBase_parameters.hpp"


namespace SDK
{

// Function BP_NPCBase.BP_NPCBase_C.GetIsIndoor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsIndoor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::GetIsIndoor(bool* IsIndoor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetIsIndoor");

	Params::BP_NPCBase_C_GetIsIndoor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsIndoor != nullptr)
		*IsIndoor = Parms.IsIndoor;
}


// Function BP_NPCBase.BP_NPCBase_C.GetBodyPartsLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EN_BodyPartsName                        Parts                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::GetBodyPartsLocation(EN_BodyPartsName Parts, struct FVector* Location, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetBodyPartsLocation");

	Params::BP_NPCBase_C_GetBodyPartsLocation Parms{};

	Parms.Parts = Parts;

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_NPCBase.BP_NPCBase_C.GetHP
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 HP                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 MaxHP_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::GetHP(double* HP, double* MaxHP_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetHP");

	Params::BP_NPCBase_C_GetHP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HP != nullptr)
		*HP = Parms.HP;

	if (MaxHP_0 != nullptr)
		*MaxHP_0 = Parms.MaxHP_0;
}


// Function BP_NPCBase.BP_NPCBase_C.GetFaction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EN_Faction*                             Faction_0                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::GetFaction(EN_Faction* Faction_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetFaction");

	Params::BP_NPCBase_C_GetFaction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Faction_0 != nullptr)
		*Faction_0 = Parms.Faction_0;
}


// Function BP_NPCBase.BP_NPCBase_C.GetCurrentWeaponSelector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EWeaponSelector*                        CurrentWeaponSelector                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::GetCurrentWeaponSelector(EWeaponSelector* CurrentWeaponSelector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetCurrentWeaponSelector");

	Params::BP_NPCBase_C_GetCurrentWeaponSelector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentWeaponSelector != nullptr)
		*CurrentWeaponSelector = Parms.CurrentWeaponSelector;
}


// Function BP_NPCBase.BP_NPCBase_C.GetEquipWeaponNames
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<EWeaponSelector, class FName>*     EquipWeapon                                            (Parm, OutParm)

void ABP_NPCBase_C::GetEquipWeaponNames(TMap<EWeaponSelector, class FName>* EquipWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetEquipWeaponNames");

	Params::BP_NPCBase_C_GetEquipWeaponNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EquipWeapon != nullptr)
		*EquipWeapon = std::move(Parms.EquipWeapon);
}


// Function BP_NPCBase.BP_NPCBase_C.GetHeadLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector*                         HeadLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::GetHeadLocation(struct FVector* HeadLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetHeadLocation");

	Params::BP_NPCBase_C_GetHeadLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HeadLocation != nullptr)
		*HeadLocation = std::move(Parms.HeadLocation);
}


// Function BP_NPCBase.BP_NPCBase_C.IsDown
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsDown_0                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::IsDown(bool* IsDown_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "IsDown");

	Params::BP_NPCBase_C_IsDown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsDown_0 != nullptr)
		*IsDown_0 = Parms.IsDown_0;
}


// Function BP_NPCBase.BP_NPCBase_C.GetNPCRowName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName*                            NPCRowName_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::GetNPCRowName(class FName* NPCRowName_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetNPCRowName");

	Params::BP_NPCBase_C_GetNPCRowName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NPCRowName_0 != nullptr)
		*NPCRowName_0 = Parms.NPCRowName_0;
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_AimMotion_CanAim
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   CanAim                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_AimMotion_CanAim(bool* CanAim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_AimMotion_CanAim");

	Params::BP_NPCBase_C_PlayerInput_AimMotion_CanAim Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanAim != nullptr)
		*CanAim = Parms.CanAim;
}


// Function BP_NPCBase.BP_NPCBase_C.UpdateHandIK
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::UpdateHandIK(double DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "UpdateHandIK");

	Params::BP_NPCBase_C_UpdateHandIK Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.ClearDeadBody
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::ClearDeadBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "ClearDeadBody");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.StartRushEvent
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::StartRushEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "StartRushEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.DeadEvent
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CountKill                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsHeadShotKill                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   KillDirection                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitPosition                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AttackerIsPlayer                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::DeadEvent(bool CountKill, bool IsHeadShotKill, const struct FVector& KillDirection, const struct FVector& HitPosition, bool AttackerIsPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "DeadEvent");

	Params::BP_NPCBase_C_DeadEvent Parms{};

	Parms.CountKill = CountKill;
	Parms.IsHeadShotKill = IsHeadShotKill;
	Parms.KillDirection = std::move(KillDirection);
	Parms.HitPosition = std::move(HitPosition);
	Parms.AttackerIsPlayer = AttackerIsPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.AutoMove_OutAreaNavMesh
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::AutoMove_OutAreaNavMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "AutoMove_OutAreaNavMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Find Set Level Manager
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Find_Set_Level_Manager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Find Set Level Manager");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.SpawnSetup
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EN_Faction                              Faction_0                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxHP_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxStamina_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_VoiceType                            VoiceType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_NPCLogicPattern                      LogicPattern_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_ShootingLevel                        ShootingLevel_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EN_MoveTaskName                         FirstMoveTask                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           PrimaryWeapon_WCSD_ForNPC                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UClass*                           SecondaryWeapon_WCSD_ForNPC                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UClass*                           MeleeWeapon_WCSD_ForNPC                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::SpawnSetup(EN_Faction Faction_0, double MaxHP_0, double MaxStamina_0, EN_VoiceType VoiceType, EN_NPCLogicPattern LogicPattern_0, EN_ShootingLevel ShootingLevel_0, EN_MoveTaskName FirstMoveTask, class UClass* PrimaryWeapon_WCSD_ForNPC, class UClass* SecondaryWeapon_WCSD_ForNPC, class UClass* MeleeWeapon_WCSD_ForNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "SpawnSetup");

	Params::BP_NPCBase_C_SpawnSetup Parms{};

	Parms.Faction_0 = Faction_0;
	Parms.MaxHP_0 = MaxHP_0;
	Parms.MaxStamina_0 = MaxStamina_0;
	Parms.VoiceType = VoiceType;
	Parms.LogicPattern_0 = LogicPattern_0;
	Parms.ShootingLevel_0 = ShootingLevel_0;
	Parms.FirstMoveTask = FirstMoveTask;
	Parms.PrimaryWeapon_WCSD_ForNPC = PrimaryWeapon_WCSD_ForNPC;
	Parms.SecondaryWeapon_WCSD_ForNPC = SecondaryWeapon_WCSD_ForNPC;
	Parms.MeleeWeapon_WCSD_ForNPC = MeleeWeapon_WCSD_ForNPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.SetupNPC_ForActorOnLevel
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::SetupNPC_ForActorOnLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "SetupNPC_ForActorOnLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.AutoMantle
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::AutoMantle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "AutoMantle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.NavLinkJump
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Destination                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::NavLinkJump(const struct FVector& Destination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "NavLinkJump");

	Params::BP_NPCBase_C_NavLinkJump Parms{};

	Parms.Destination = std::move(Destination);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.BPI_Get_CurrentStates
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMovementMode*                          PawnMovementMode                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_MovementState*                     MovementState_0                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_MovementState*                     PrevMovementState_0                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_MovementAction*                    MovementAction_0                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_RotationMode*                      RotationMode_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_Gait*                              ActualGait                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_Stance*                            ActualStance                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_ViewMode*                          ViewMode_0                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_OverlayState*                      OverlayState_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ELeanState*                             LeanState_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EWeaponMotionState*                     WeaponMotionState                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::BPI_Get_CurrentStates(EMovementMode* PawnMovementMode, EALS_MovementState* MovementState_0, EALS_MovementState* PrevMovementState_0, EALS_MovementAction* MovementAction_0, EALS_RotationMode* RotationMode_0, EALS_Gait* ActualGait, EALS_Stance* ActualStance, EALS_ViewMode* ViewMode_0, EALS_OverlayState* OverlayState_0, ELeanState* LeanState_0, EWeaponMotionState* WeaponMotionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BPI_Get_CurrentStates");

	Params::BP_NPCBase_C_BPI_Get_CurrentStates Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PawnMovementMode != nullptr)
		*PawnMovementMode = Parms.PawnMovementMode;

	if (MovementState_0 != nullptr)
		*MovementState_0 = Parms.MovementState_0;

	if (PrevMovementState_0 != nullptr)
		*PrevMovementState_0 = Parms.PrevMovementState_0;

	if (MovementAction_0 != nullptr)
		*MovementAction_0 = Parms.MovementAction_0;

	if (RotationMode_0 != nullptr)
		*RotationMode_0 = Parms.RotationMode_0;

	if (ActualGait != nullptr)
		*ActualGait = Parms.ActualGait;

	if (ActualStance != nullptr)
		*ActualStance = Parms.ActualStance;

	if (ViewMode_0 != nullptr)
		*ViewMode_0 = Parms.ViewMode_0;

	if (OverlayState_0 != nullptr)
		*OverlayState_0 = Parms.OverlayState_0;

	if (LeanState_0 != nullptr)
		*LeanState_0 = Parms.LeanState_0;

	if (WeaponMotionState != nullptr)
		*WeaponMotionState = Parms.WeaponMotionState;
}


// Function BP_NPCBase.BP_NPCBase_C.BPI_Get_EssentialValues
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector*                         Velocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Acceleration_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         MovementInput                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsMoving_0                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasMovementInput_0                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Speed_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 MovementInputAmount_0                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator*                        AimingRotation_0                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double*                                 AimYawRate_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 CameraRollAngle_0                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 CameraPitchAngle_0                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 RecoilHandAngle_0                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsTriggerPull                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsTriggerOFF                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         HandIK_Location_L_0                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator*                        HandIK_Rotation_L_0                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double*                                 HoldBreathFactor                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 LeanAlpha_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   WeaponAttachHandIsRight                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsPlayer                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 PlayerHeadBobAlpha                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStr_KickAnimValue*              KickAnimValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::BPI_Get_EssentialValues(struct FVector* Velocity, struct FVector* Acceleration_0, struct FVector* MovementInput, bool* IsMoving_0, bool* HasMovementInput_0, double* Speed_0, double* MovementInputAmount_0, struct FRotator* AimingRotation_0, double* AimYawRate_0, double* CameraRollAngle_0, double* CameraPitchAngle_0, double* RecoilHandAngle_0, bool* IsTriggerPull, bool* IsTriggerOFF, struct FVector* HandIK_Location_L_0, struct FRotator* HandIK_Rotation_L_0, double* HoldBreathFactor, double* LeanAlpha_0, bool* WeaponAttachHandIsRight, bool* IsPlayer, double* PlayerHeadBobAlpha, struct FStr_KickAnimValue* KickAnimValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BPI_Get_EssentialValues");

	Params::BP_NPCBase_C_BPI_Get_EssentialValues Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Velocity != nullptr)
		*Velocity = std::move(Parms.Velocity);

	if (Acceleration_0 != nullptr)
		*Acceleration_0 = std::move(Parms.Acceleration_0);

	if (MovementInput != nullptr)
		*MovementInput = std::move(Parms.MovementInput);

	if (IsMoving_0 != nullptr)
		*IsMoving_0 = Parms.IsMoving_0;

	if (HasMovementInput_0 != nullptr)
		*HasMovementInput_0 = Parms.HasMovementInput_0;

	if (Speed_0 != nullptr)
		*Speed_0 = Parms.Speed_0;

	if (MovementInputAmount_0 != nullptr)
		*MovementInputAmount_0 = Parms.MovementInputAmount_0;

	if (AimingRotation_0 != nullptr)
		*AimingRotation_0 = std::move(Parms.AimingRotation_0);

	if (AimYawRate_0 != nullptr)
		*AimYawRate_0 = Parms.AimYawRate_0;

	if (CameraRollAngle_0 != nullptr)
		*CameraRollAngle_0 = Parms.CameraRollAngle_0;

	if (CameraPitchAngle_0 != nullptr)
		*CameraPitchAngle_0 = Parms.CameraPitchAngle_0;

	if (RecoilHandAngle_0 != nullptr)
		*RecoilHandAngle_0 = Parms.RecoilHandAngle_0;

	if (IsTriggerPull != nullptr)
		*IsTriggerPull = Parms.IsTriggerPull;

	if (IsTriggerOFF != nullptr)
		*IsTriggerOFF = Parms.IsTriggerOFF;

	if (HandIK_Location_L_0 != nullptr)
		*HandIK_Location_L_0 = std::move(Parms.HandIK_Location_L_0);

	if (HandIK_Rotation_L_0 != nullptr)
		*HandIK_Rotation_L_0 = std::move(Parms.HandIK_Rotation_L_0);

	if (HoldBreathFactor != nullptr)
		*HoldBreathFactor = Parms.HoldBreathFactor;

	if (LeanAlpha_0 != nullptr)
		*LeanAlpha_0 = Parms.LeanAlpha_0;

	if (WeaponAttachHandIsRight != nullptr)
		*WeaponAttachHandIsRight = Parms.WeaponAttachHandIsRight;

	if (IsPlayer != nullptr)
		*IsPlayer = Parms.IsPlayer;

	if (PlayerHeadBobAlpha != nullptr)
		*PlayerHeadBobAlpha = Parms.PlayerHeadBobAlpha;

	if (KickAnimValue != nullptr)
		*KickAnimValue = std::move(Parms.KickAnimValue);
}


// Function BP_NPCBase.BP_NPCBase_C.MantleStart
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  MantleHeight                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FALS_ComponentAndTransform&MantleLedgeWS                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// EMantleType                             MantleType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::MantleStart(double MantleHeight, const struct FALS_ComponentAndTransform& MantleLedgeWS, EMantleType MantleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "MantleStart");

	Params::BP_NPCBase_C_MantleStart Parms{};

	Parms.MantleHeight = MantleHeight;
	Parms.MantleLedgeWS = std::move(MantleLedgeWS);
	Parms.MantleType = MantleType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.RagdollEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::RagdollEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "RagdollEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.RagdollStart
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::RagdollStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "RagdollStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.GetGetUpAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    RagdollFaceUp_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class UAnimMontage* ABP_NPCBase_C::GetGetUpAnimation(bool RagdollFaceUp_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetGetUpAnimation");

	Params::BP_NPCBase_C_GetGetUpAnimation Parms{};

	Parms.RagdollFaceUp_0 = RagdollFaceUp_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_NPCBase.BP_NPCBase_C.MantleEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::MantleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "MantleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.GetRollAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class UAnimMontage* ABP_NPCBase_C::GetRollAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetRollAnimation");

	Params::BP_NPCBase_C_GetRollAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_NPCBase.BP_NPCBase_C.OnOverlayStateChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_OverlayState                       NewOverlayState                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::OnOverlayStateChanged(EALS_OverlayState NewOverlayState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "OnOverlayStateChanged");

	Params::BP_NPCBase_C_OnOverlayStateChanged Parms{};

	Parms.NewOverlayState = NewOverlayState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.BPI_Get_3P_TraceParams
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector*                         TraceOrigin                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 TraceRadius                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETraceTypeQuery*                        TraceChannel                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::BPI_Get_3P_TraceParams(struct FVector* TraceOrigin, double* TraceRadius, ETraceTypeQuery* TraceChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BPI_Get_3P_TraceParams");

	Params::BP_NPCBase_C_BPI_Get_3P_TraceParams Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TraceOrigin != nullptr)
		*TraceOrigin = std::move(Parms.TraceOrigin);

	if (TraceRadius != nullptr)
		*TraceRadius = Parms.TraceRadius;

	if (TraceChannel != nullptr)
		*TraceChannel = Parms.TraceChannel;
}


// Function BP_NPCBase.BP_NPCBase_C.GetMantleAsset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EMantleType                             MantleType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FMantle_Asset                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

struct FMantle_Asset ABP_NPCBase_C::GetMantleAsset(EMantleType MantleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "GetMantleAsset");

	Params::BP_NPCBase_C_GetMantleAsset Parms{};

	Parms.MantleType = MantleType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_NPCBase.BP_NPCBase_C.UpdateLayeringColors
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::UpdateLayeringColors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "UpdateLayeringColors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.UpdateColoringSystem
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::UpdateColoringSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "UpdateColoringSystem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.ResetColors
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::ResetColors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "ResetColors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.SetDynamicMaterials
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::SetDynamicMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "SetDynamicMaterials");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.BPI_Get_FP_CameraTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_NPCBase_C::BPI_Get_FP_CameraTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BPI_Get_FP_CameraTarget");

	Params::BP_NPCBase_C_BPI_Get_FP_CameraTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_NPCBase.BP_NPCBase_C.BPI_Get_3P_PivotTarget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FTransform ABP_NPCBase_C::BPI_Get_3P_PivotTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BPI_Get_3P_PivotTarget");

	Params::BP_NPCBase_C_BPI_Get_3P_PivotTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_NPCBase.BP_NPCBase_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.RecoilHandTimeLine__FinishedFunc
// (BlueprintEvent)

void ABP_NPCBase_C::RecoilHandTimeLine__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "RecoilHandTimeLine__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.RecoilHandTimeLine__UpdateFunc
// (BlueprintEvent)

void ABP_NPCBase_C::RecoilHandTimeLine__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "RecoilHandTimeLine__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.MoveSpeedDown__FinishedFunc
// (BlueprintEvent)

void ABP_NPCBase_C::MoveSpeedDown__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "MoveSpeedDown__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.MoveSpeedDown__UpdateFunc
// (BlueprintEvent)

void ABP_NPCBase_C::MoveSpeedDown__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "MoveSpeedDown__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.RefreshWeapon
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::RefreshWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "RefreshWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_UseWeapon
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Press_Released                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_UseWeapon(bool Press_Released)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_UseWeapon");

	Params::BP_NPCBase_C_PlayerInput_UseWeapon Parms{};

	Parms.Press_Released = Press_Released;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_ReloadWeapon
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::PlayerInput_ReloadWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_ReloadWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_SwitchLight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPressed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_SwitchLight(bool IsPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_SwitchLight");

	Params::BP_NPCBase_C_PlayerInput_SwitchLight Parms{};

	Parms.IsPressed = IsPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_Interact
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::PlayerInput_Interact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_Interact");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_SwitchWeapon
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EWeaponSelector                         SwitchTo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_SwitchWeapon(EWeaponSelector SwitchTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_SwitchWeapon");

	Params::BP_NPCBase_C_PlayerInput_SwitchWeapon Parms{};

	Parms.SwitchTo = SwitchTo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_ScrollWeapon
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsUp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_ScrollWeapon(bool IsUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_ScrollWeapon");

	Params::BP_NPCBase_C_PlayerInput_ScrollWeapon Parms{};

	Parms.IsUp = IsUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_Charge
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Press_Released                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_Charge(bool Press_Released)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_Charge");

	Params::BP_NPCBase_C_PlayerInput_Charge Parms{};

	Parms.Press_Released = Press_Released;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_Lean
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    In                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsRight                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_Lean(bool In, bool IsRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_Lean");

	Params::BP_NPCBase_C_PlayerInput_Lean Parms{};

	Parms.In = In;
	Parms.IsRight = IsRight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_AimMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    AimIN                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MuteSE                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_AimMotion(bool AimIN, bool MuteSE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_AimMotion");

	Params::BP_NPCBase_C_PlayerInput_AimMotion Parms{};

	Parms.AimIN = AimIN;
	Parms.MuteSE = MuteSE;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_MeleeAttack
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Press_Released                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_MeleeAttack(bool Press_Released)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_MeleeAttack");

	Params::BP_NPCBase_C_PlayerInput_MeleeAttack Parms{};

	Parms.Press_Released = Press_Released;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.PlayerInput_HoldBreath
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::PlayerInput_HoldBreath(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "PlayerInput_HoldBreath");

	Params::BP_NPCBase_C_PlayerInput_HoldBreath Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "ReceiveTick");

	Params::BP_NPCBase_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.OpenShellCarrier
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::OpenShellCarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "OpenShellCarrier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Recoil
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Recoil_Horizontal                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Recoil_Vertical                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::Recoil(double Recoil_Horizontal, double Recoil_Vertical)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Recoil");

	Params::BP_NPCBase_C_Recoil Parms{};

	Parms.Recoil_Horizontal = Recoil_Horizontal;
	Parms.Recoil_Vertical = Recoil_Vertical;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.ChangeEquipWeapon
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EWeaponSelector                         WeaponSlot                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Weapon                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::ChangeEquipWeapon(EWeaponSelector WeaponSlot, class UClass* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "ChangeEquipWeapon");

	Params::BP_NPCBase_C_ChangeEquipWeapon Parms{};

	Parms.WeaponSlot = WeaponSlot;
	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.BulletHitEvent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitDirection                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  HitDamage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  HitStunPower                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DoT_Damage                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DoT_Stun                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DoT_Time                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DoT_Interval                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPenetrated                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             HitBoneName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   AttackLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ShooterActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        HitSurfaceType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsMultipleShot                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             ShotID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AmmoRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::BulletHitEvent(const struct FVector& HitLocation, const struct FVector& HitDirection, double HitDamage, double HitStunPower, double DoT_Damage, double DoT_Stun, double DoT_Time, double DoT_Interval, bool IsPenetrated, class FName HitBoneName, const struct FVector& AttackLocation, class AActor* ShooterActor, EPhysicalSurface HitSurfaceType, bool IsMultipleShot, class FName ShotID, class FName AmmoRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BulletHitEvent");

	Params::BP_NPCBase_C_BulletHitEvent Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitDirection = std::move(HitDirection);
	Parms.HitDamage = HitDamage;
	Parms.HitStunPower = HitStunPower;
	Parms.DoT_Damage = DoT_Damage;
	Parms.DoT_Stun = DoT_Stun;
	Parms.DoT_Time = DoT_Time;
	Parms.DoT_Interval = DoT_Interval;
	Parms.IsPenetrated = IsPenetrated;
	Parms.HitBoneName = HitBoneName;
	Parms.AttackLocation = std::move(AttackLocation);
	Parms.ShooterActor = ShooterActor;
	Parms.HitSurfaceType = HitSurfaceType;
	Parms.IsMultipleShot = IsMultipleShot;
	Parms.ShotID = ShotID;
	Parms.AmmoRowName = AmmoRowName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_NPCBase_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.StartJumpTimer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Destination                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::StartJumpTimer(const struct FVector& Destination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "StartJumpTimer");

	Params::BP_NPCBase_C_StartJumpTimer Parms{};

	Parms.Destination = std::move(Destination);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.JumpCheck
// (BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::JumpCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "JumpCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.StopTimer
// (BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::StopTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "StopTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Death
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CountKill                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::Death(bool CountKill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Death");

	Params::BP_NPCBase_C_Death Parms{};

	Parms.CountKill = CountKill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.StartRush
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::StartRush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "StartRush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_InsertMag_End
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_InsertMag_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_InsertMag_End");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_InsertMag_Begin
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_InsertMag_Begin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_InsertMag_Begin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_TakeNewMag
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_TakeNewMag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_TakeNewMag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_DropMag
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_DropMag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_DropMag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_DetachMag
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_DetachMag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_DetachMag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Chambering_BoltCatchRelease
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Chambering_BoltCatchRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Chambering_BoltCatchRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_TakeNewShell
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_TakeNewShell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_TakeNewShell");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_InsertShell_Begin
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_InsertShell_Begin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_InsertShell_Begin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_InsertShell_End
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_InsertShell_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_InsertShell_End");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.WeaponLightControl
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    In                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           LightONArea_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::WeaponLightControl(bool In, class AActor* LightONArea_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "WeaponLightControl");

	Params::BP_NPCBase_C_WeaponLightControl Parms{};

	Parms.In = In;
	Parms.LightONArea_0 = LightONArea_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.WeaponLightSwitchControl
// (BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::WeaponLightSwitchControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "WeaponLightSwitchControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.SetTextAndColor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      Text                                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FColor&                    Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::SetTextAndColor(const class FText& Text, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "SetTextAndColor");

	Params::BP_NPCBase_C_SetTextAndColor Parms{};

	Parms.Text = std::move(Text);
	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.HealHP
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  HealAmount                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::HealHP(double HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "HealHP");

	Params::BP_NPCBase_C_HealHP Parms{};

	Parms.HealAmount = HealAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.SetIsIndoor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsIndoor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::SetIsIndoor(bool IsIndoor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "SetIsIndoor");

	Params::BP_NPCBase_C_SetIsIndoor Parms{};

	Parms.IsIndoor = IsIndoor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_NPCBase_C::BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_NPCBase_C_BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature");

	Params::BP_NPCBase_C_BndEvt__BP_NPCBase_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.CheckIsIndoor
// (BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::CheckIsIndoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "CheckIsIndoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.Reload_InsertMag_Block
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::Reload_InsertMag_Block()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "Reload_InsertMag_Block");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.RefreshAITask
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_NPCBase_C::RefreshAITask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "RefreshAITask");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NPCBase.BP_NPCBase_C.DoTEvent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Stun                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttackerRowName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AmmoRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::DoTEvent(double Damage, double Stun, class FName AttackerRowName, class FName AmmoRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "DoTEvent");

	Params::BP_NPCBase_C_DoTEvent Parms{};

	Parms.Damage = Damage;
	Parms.Stun = Stun;
	Parms.AttackerRowName = AttackerRowName;
	Parms.AmmoRowName = AmmoRowName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NPCBase.BP_NPCBase_C.ExecuteUbergraph_BP_NPCBase
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NPCBase_C::ExecuteUbergraph_BP_NPCBase(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NPCBase_C", "ExecuteUbergraph_BP_NPCBase");

	Params::BP_NPCBase_C_ExecuteUbergraph_BP_NPCBase Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}

}

